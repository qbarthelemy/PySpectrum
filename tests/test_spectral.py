"""Tests for module spectral.

To execute tests:
>>> pytest -k test_spectral
"""

import pytest
import numpy as np
from pyspectrum.spectral import rescale, detect_peak


def generate_pure_1f_curve(fs, size, a, b):
    """Generate a pure 1/f curve"""
    freqs = np.fft.rfftfreq(size, 1/fs)

    # ignore division by zero generated by negative power on frequency 0
    with np.errstate(divide='ignore'):
        spec = np.power(freqs, a)[np.newaxis, :] * np.exp(b)
    return spec, freqs


def generate_noisy_1f_curve(size, fs, a, b, n, seed):
    """Generate a noisy 1/f curve"""
    np.random.seed(seed)
    freqs = np.fft.rfftfreq(size, 1/fs)

    # ignore division by zero generated by negative power on frequency 0
    with np.errstate(divide='ignore'):
        spec = np.power(freqs, a)[np.newaxis, :] * np.exp(b)
    spec += n * np.random.normal(0, 1, size=spec.shape)
    spec = np.clip(spec, a_min=1e-2, a_max=None)  # avoid negative values
    return spec, freqs


def generate_peaky_1f_curve(size, fs, a, b, n, peak_low, peak_high, seed):
    """Generate a peaky 1/f curve"""
    np.random.seed(seed)
    freqs = np.fft.rfftfreq(size, 1/fs)

    # ignore division by zero generated by negative power on frequency 0
    with np.errstate(divide='ignore'):
        spec = np.power(freqs, a)[np.newaxis, :] * np.exp(b)
    spec += n * np.random.normal(0, 1, size=spec.shape)
    spec += 20.0 * np.exp(-0.1*(freqs-0.5*(peak_low+peak_high))**2)
    spec[:, np.isclose(freqs, 50, atol=freqs[1]-freqs[0])] *= 10
    spec = np.clip(spec, a_min=1e-2, a_max=None)  # avoid negative values
    return spec, freqs


###############################################################################


@pytest.mark.parametrize(
    "fs, size, coeff_a, coeff_b",
    [
        (256, 256*2, -0.7, 5),
        (512, 512, -1, 0),
        (512, 512, -1.5, 0),
    ],
)
@pytest.mark.parametrize("rescaling", ['y-intercept', 'slope', 'complete'])
def test_rescale_pure(fs, size, coeff_a, coeff_b, rescaling):
    """Test rescale on a pure 1/f curve"""
    spectrum, freqs = generate_pure_1f_curve(fs, size, coeff_a, coeff_b)

    spectrum_r, coeffs = rescale(spectrum, freqs, rescaling=rescaling)

    # check that the regression is correct
    assert np.allclose(coeffs, [coeff_a, coeff_b], atol=1e-10)

    if rescaling in ['y-intercept', 'complete']:
        # check that intercept=1 after y-intercept and complete rescalings,
        # testing at 1Hz because it is the intercept in log-log space: log(1)=0
        idx_1hz = np.where(freqs == 1)[0]
        assert np.allclose(spectrum_r[:, idx_1hz], 1, atol=1e-10)


@pytest.mark.parametrize(
    "fs, size, coeff_a, coeff_b, coeff_noise",
    [
        (256, 256*2, -0.7, 5, 1.5),
        (512, 512, -0.4, 2, 0.1),
    ],
)
@pytest.mark.parametrize("rescaling", ['y-intercept', 'slope', 'complete'])
def test_rescale_noisy(fs, size, coeff_a, coeff_b, coeff_noise, rescaling):
    """Test rescale on a noisy 1/f curve"""
    spectrum, freqs = generate_noisy_1f_curve(
        fs,
        size,
        coeff_a,
        coeff_b,
        coeff_noise,
        1234
    )

    spectrum_r, coeffs = rescale(spectrum, freqs, rescaling=rescaling)

    # check that the regression is correct
    assert np.allclose(coeffs, [coeff_a, coeff_b], rtol=1e-1)

    if rescaling in ['y-intercept', 'complete']:
        # check that intercept=1 after y-intercept and complete rescalings,
        # testing at 1Hz because it is the intercept in log-log space: log(1)=0
        idx_1hz = np.where(freqs == 1)[0]
        assert np.allclose(spectrum_r[:, idx_1hz], 1, rtol=1e-1)


@pytest.mark.parametrize(
    "fs, size, coeff_a, coeff_b, coeff_noise, peak_low, peak_high",
    [
        (256, 256*2, -0.7, 5, 2, 8, 12),
        (512, 512, -0.5, 4, 1, 8, 12),
    ],
)
@pytest.mark.parametrize("rescaling", ['y-intercept', 'slope', 'complete'])
def test_rescale_peaky(fs, size, coeff_a, coeff_b, coeff_noise, peak_low, peak_high, rescaling):
    """Test rescale on a peaky and noisy 1/f curve"""
    spectrum, freqs = generate_peaky_1f_curve(
        size,
        fs,
        coeff_a,
        coeff_b,
        coeff_noise,
        peak_low,
        peak_high,
        1234,
    )

    # normal fit
    spectrum_r, coeffs = rescale(spectrum, freqs, rescaling=rescaling)
    assert np.allclose(coeffs, [coeff_a, coeff_b], rtol=2e-1)

    if rescaling in ['y-intercept', 'complete']:
        # check that intercept=1 after y-intercept and complete rescalings,
        # testing at 1Hz because it is the intercept in log-log space: log(1)=0
        idx_1hz = np.where(freqs == 1)[0]
        assert np.allclose(spectrum_r[:, idx_1hz], 1, rtol=4e-1)

    # fit excluding peak => more robust => more precise
    foi = (freqs >= 1) & (freqs < 95) & ~ ((freqs >= peak_low) & (freqs < peak_high))
    spectrum_r, coeffs = rescale(spectrum, freqs, rescaling=rescaling, foi=foi)
    assert np.allclose(coeffs, [coeff_a, coeff_b], rtol=1e-1)

    if rescaling in ['y-intercept', 'complete']:
        # check that intercept=1 after y-intercept and complete rescalings,
        # testing at 1Hz because it is the intercept in log-log space: log(1)=0
        idx_1hz = np.where(freqs == 1)[0]
        assert np.allclose(spectrum_r[:, idx_1hz], 1, rtol=3e-1)


@pytest.mark.parametrize(
    "fs, size, coeff_a, coeff_b, coeff_noise, peak_low, peak_high",
    [
        (256, 256*2, -0.7, 5, 2, 8, 12),
        (512, 512, -0.5, 4, 1, 8, 12),
    ],
)
@pytest.mark.parametrize("rescaling", ['y-intercept', 'slope', 'complete'])
def test_rescale_doc(fs, size, coeff_a, coeff_b, coeff_noise, peak_low, peak_high, rescaling):
    """ Test rescale on simulated data
        to show equivalence between indexing method (see documentation)
    """
    spectrum, freqs = generate_peaky_1f_curve(
        size,
        fs,
        coeff_a,
        coeff_b,
        coeff_noise,
        peak_low,
        peak_high,
        1234,
    )

    foi = (freqs >= 1) & (freqs < 95) & ~((freqs >= peak_low) & (freqs < peak_high))
    spectrum_r1, coeffs_1 = rescale(spectrum, freqs, rescaling=rescaling, foi=foi)

    frequency_resolution = freqs[1] - freqs[0]
    foi = np.r_[
        int(np.floor(1/frequency_resolution)):int(np.floor(peak_low/frequency_resolution)),
        int(np.floor(peak_high/frequency_resolution)):int(np.floor(95/frequency_resolution)),
    ]
    spectrum_r2, coeffs_2 = rescale(spectrum, freqs, rescaling=rescaling, foi=foi)

    assert np.allclose(spectrum_r1, spectrum_r2, atol=1e-10)
    assert np.allclose(coeffs_1, coeffs_2, atol=1e-10)


@pytest.mark.parametrize(
    "fs, size, coeff_a, coeff_b, coeff_noise",
    [
        (256, 256*2, -0.7, 5, 1.5),
        (512, 512, -0.4, 2, 0.1),
    ],
)
def test_detect_peak_noisy(fs, size, coeff_a, coeff_b, coeff_noise):
    """Test detect_peak on a noisy 1/f curve"""
    spectrum, freqs = generate_noisy_1f_curve(
        size,
        fs,
        coeff_a,
        coeff_b,
        coeff_noise,
        1234,
    )

    peak_freqs = detect_peak(
        spectrum,
        freqs,
        band_target=(8, 12),
    )

    assert np.all(np.isnan(peak_freqs))


@pytest.mark.parametrize(
    "fs, size, coeff_a, coeff_b, coeff_noise, peak_low, peak_high",
    [
        (256, 256*2, -0.7, 5, 2, 8, 12),
        (512, 512, -0.5, 4, 1, 8, 12),
        (256, 256*2, -0.7, 5, 2, 16, 24),
        (512, 512, -0.5, 4, 1, 16, 24),
    ],
)
def test_detect_peak_peaky(fs, size, coeff_a, coeff_b, coeff_noise, peak_low, peak_high):
    """Test detect_peak on a peaky and noisy 1/f curve"""
    spectrum, freqs = generate_peaky_1f_curve(
        size,
        fs,
        coeff_a,
        coeff_b,
        coeff_noise,
        peak_low,
        peak_high,
        1234,
    )

    peak_freqs = detect_peak(
        spectrum,
        freqs,
        band_target=(peak_low, peak_high),
    )

    assert np.allclose(peak_freqs, (peak_low+peak_high)/2,
                       rtol=freqs[1] - freqs[0])
